# HOIL: Human Oriented Intermediate Language

HOIL (Human Oriented Intermediate Language) is the textual representation of COIL (Compiler Optimization Intermediate Language). While COIL is designed as a binary format for efficiency, HOIL provides a human-readable syntax that makes it easier to read, write, and understand the underlying code.

## Purpose of HOIL

HOIL serves several important purposes in the COIL ecosystem:

1. **Human Readability**: Makes COIL code accessible to human readers and writers
2. **Debugging Aid**: Helps developers inspect and debug intermediate representation
3. **Educational Tool**: Aids in learning and understanding the COIL model
4. **Direct Programming**: Allows direct programming in the intermediate language
5. **Testing Tool**: Facilitates testing of COIL assemblers and compilers

## Relationship to COIL

HOIL is a direct 1:1 mapping to COIL binary format. Every HOIL construct has a corresponding COIL binary representation, and vice versa. This means:

- HOIL can be reliably converted to COIL binary
- COIL binary can be decompiled to HOIL
- No semantic information is lost in translation

```
            +-----------+             +-----------+
            |   HOIL    |   Compile   |   COIL    |
            |  (Text)   | ----------> |  (Binary) |
            +-----------+             +-----------+
                 ^                          |
                 |                          |
                 |  Decompile               |
                 +--------------------------|
```

## Key Characteristics

- **Lightweight Syntax**: Optimized for both readability and writeability
- **Type Safety**: Maintains COIL's strong type system
- **Direct Hardware Mapping**: Maps clearly to hardware concepts
- **Explicit Semantics**: Makes all operations explicit
- **Bare-Metal Ready**: Works in environments without runtime dependencies

## When to Use HOIL

HOIL is particularly useful in these scenarios:

1. **Developing COIL Assemblers**: Test and verify assembler implementations
2. **Optimizing Compilers**: Inspect the intermediate representation generated by compilers
3. **Learning COIL**: Study the IR without dealing with binary formats
4. **Hand-Tuning Performance**: Manually optimize critical code sections
5. **Implementing Specific Algorithms**: Directly implement algorithms at the IR level
6. **Bare-Metal Programming**: Direct access to hardware features

## Basic Structure of HOIL Code

HOIL programs follow this general structure:

```
// Module declaration
MODULE "example";

// Type definitions
TYPE point { x: f32, y: f32 }

// Global variables
GLOBAL g_counter: i32 = 0;

// Function declaration
FUNCTION add(a: i32, b: i32) -> i32 {
    ENTRY:
        add_result = ADD a, b;
        RET add_result;
}

// Device-class specific function implementation
FUNCTION vector_multiply(a: vec<f32,4>, b: vec<f32,4>) -> vec<f32,4>
TARGET "GPU" {
    ENTRY:
        result = VMUL a, b;
        RET result;
}
```

## HOIL vs. Traditional Assembly

While HOIL may look similar to traditional assembly languages, it has several key differences:

| Feature | Traditional Assembly | HOIL |
|---------|---------------------|------|
| Type System | Weak or implicit | Strong and explicit |
| Abstraction | Machine-specific | Architecture-neutral with target specialization |
| Memory Model | Platform-specific | Explicit memory spaces |
| Portability | Limited to one architecture | Works across diverse processing units |
| Optimization | Limited or manual | Rich optimization hints |
| Target Specification | Implicit | Explicit target declarations |

## Example: HOIL Hello World

Here's a simple "Hello World" program in HOIL:

```
MODULE "hello_world";

// External function declaration from runtime
EXTERN FUNCTION puts(str: ptr<i8>) -> i32;

// String constant
CONSTANT hello_str: array<i8> = "Hello, HOIL World!\00";

// Main function
FUNCTION main() -> i32 {
    ENTRY:
        str_ptr = LEA hello_str;
        result = CALL puts(str_ptr);
        RET 0;
}
```

## Converting Between HOIL and COIL

HOIL can be converted to COIL binary format using a HOIL compiler:

```
$ hoil-compiler hello.hoil -o hello.coil
```

Similarly, COIL binary can be decompiled to HOIL:

```
$ coil-decompiler hello.coil -o hello.hoil
```

These tools enable round-trip engineering between the human-readable and binary representations.

## Features and Examples

HOIL supports all COIL features, including:

### Type System

```
// Primitive types
TYPE age: i32;

// Composite types
TYPE point {
    x: f32,
    y: f32,
    z: f32
}

// Array types
TYPE buffer: array<u8, 1024>;

// Vector types for SIMD
TYPE vector4: vec<f32, 4>;

// Function types
TYPE callback: function(a: i32, b: i32) -> i32;
```

### Memory Operations

```
FUNCTION memory_example(ptr: ptr<i32>, index: i32) -> i32 {
    ENTRY:
        // Load from memory
        value = LOAD ptr;
        
        // Compute address with offset
        offset_ptr = ADD ptr, MUL index, 4;
        
        // Store to memory
        STORE offset_ptr, value;
        
        // Memory fence
        FENCE memory;
        
        // Return loaded value
        RET value;
}
```

### Control Flow

```
FUNCTION max(a: i32, b: i32) -> i32 {
    ENTRY:
        // Compare values
        is_greater = CMP_GT a, b;
        
        // Conditional branch
        BR is_greater, THEN, ELSE;
        
    THEN:
        RET a;
        
    ELSE:
        RET b;
}
```

### Vector Operations

```
FUNCTION vector_add(a: vec<f32, 4>, b: vec<f32, 4>) -> vec<f32, 4> {
    ENTRY:
        // Vector addition
        result = VADD a, b;
        
        // Return vector result
        RET result;
}
```

### Target-Specific Code

```
// Default implementation
FUNCTION calculate_sum(arr: ptr<f32>, count: i32) -> f32 {
    ENTRY:
        sum = LOAD_F32 0.0;
        i = LOAD_I32 0;
        BR ALWAYS, LOOP_CHECK;
        
    LOOP_CHECK:
        is_done = CMP_GE i, count;
        BR is_done, DONE, LOOP_BODY;
        
    LOOP_BODY:
        ptr = ADD arr, MUL i, 4;
        val = LOAD ptr;
        sum = FADD sum, val;
        i = ADD i, 1;
        BR ALWAYS, LOOP_CHECK;
        
    DONE:
        RET sum;
}

// Implementation for CPU device class
FUNCTION calculate_sum(arr: ptr<f32>, count: i32) -> f32
TARGET "CPU" {
    ENTRY:
        // Vector operations will be handled appropriately by the assembler
        // whether or not the hardware has native vector support
        sum_vec = VSPLAT 0.0, 8;  // 8 lanes of zeros
        i = LOAD_I32 0;
        step = LOAD_I32 8;  // Process 8 elements at a time
        BR ALWAYS, VECTOR_LOOP_CHECK;
        
    VECTOR_LOOP_CHECK:
        can_vector = CMP_LE ADD i, step, count;
        BR can_vector, VECTOR_LOOP, SCALAR_REMAINDER;
        
    VECTOR_LOOP:
        ptr = ADD arr, MUL i, 4;
        vec = VLOAD ptr;
        sum_vec = VADD sum_vec, vec;
        i = ADD i, step;
        BR ALWAYS, VECTOR_LOOP_CHECK;
        
    SCALAR_REMAINDER:
        // Handle remaining elements...
        
    REDUCE:
        // Horizontal sum of vector
        result = VREDUCE_ADD sum_vec;
        RET result;
}
```

## Next Steps

To learn more about HOIL, explore the following resources:

- [HOIL Syntax Reference](syntax.md): Detailed syntax specification
- [HOIL to COIL Conversion](conversion.md): How HOIL maps to COIL binary
- [HOIL Examples](examples/): Example programs in HOIL

For practical usage of HOIL in development workflows, check out the compiler and assembler guides:

- [Compiler Developer Guide](../compiler-guide/README.md): How HOIL fits into compiler development
- [Assembler Creator Guide](../assembler-guide/README.md): Using HOIL to test and develop assemblers