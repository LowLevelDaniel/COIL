# COIL Instruction Set Architecture Specification (Version 1)

## Overview

The COIL (Compact Operation Instruction Language) Instruction Set Architecture defines a flexible binary instruction format designed for efficiency and portability across different hardware platforms. COIL follows a type-determined instruction philosophy where behavior is inferred from operand types, enabling compact representation while maintaining expressive power.

COIL combines the advantages of a RISC-style instruction set with the expressiveness typically found in higher-level languages. It features a comprehensive type system, platform-independent variable abstraction, and direct access to hardware registers when needed.

## 1. Instruction Format

Instructions in COIL follow a compact, variable-length format that minimizes code size while preserving flexibility:

```
No operand instruction:
[opcode: uint8_t]

Instruction with operands:
[opcode: uint8_t][operand_count: uint8_t][[operand: Operand]...]

Where Operand = [type: uint16_t][data: (type-dependent variable length)]
```

The type field (uint16_t) consists of two parts:
- Main type (first 8 bits): Describes the data width and operation type
- Extension bits (second 8 bits): Contains storage qualifiers and instruction modifiers

This encoding allows COIL to represent complex operations with minimal overhead, as the type system handles many of the details that would require separate opcodes in other architectures.

## 2. Platform Identification

COIL uses a platform identification byte in the binary header to specify which register set should be used for register encodings:

```
PLATFORM_X86_64  = 0x01
PLATFORM_X86_32  = 0x02
PLATFORM_ARM64   = 0x03
PLATFORM_ARM32   = 0x04
PLATFORM_RISCV64 = 0x05
PLATFORM_RISCV32 = 0x06
PLATFORM_CUSTOM  = 0xFE
PLATFORM_GENERIC = 0xFF  // For platform-independent code
```

## 3. Type System

The COIL type system is central to the architecture, allowing for precise control over data representation and operations. Types are encoded in 16 bits, with the first 8 bits representing the main type and the second 8 bits representing type extensions.

### 3.1 Main Types (First 8 bits)

```
// Fixed width signed integers
TYPE_INT8   = 0x01  // 8-bit signed integer
TYPE_INT16  = 0x02  // 16-bit signed integer
TYPE_INT32  = 0x03  // 32-bit signed integer
TYPE_INT64  = 0x04  // 64-bit signed integer
TYPE_INT128 = 0x05  // 128-bit signed integer

// Fixed width unsigned integers
TYPE_UNT8   = 0x10  // 8-bit unsigned integer
TYPE_UNT16  = 0x12  // 16-bit unsigned integer
TYPE_UNT32  = 0x13  // 32-bit unsigned integer
TYPE_UNT64  = 0x14  // 64-bit unsigned integer
TYPE_UNT128 = 0x15  // 128-bit unsigned integer
  
// Fixed width floating point
TYPE_FP8e5m2 = 0x20  // 8-bit float (5-bit exponent, 2-bit mantissa)
TYPE_FP8e4m3 = 0x21  // 8-bit float (4-bit exponent, 3-bit mantissa)
TYPE_FP16b   = 0x22  // bfloat16
TYPE_FP16    = 0x23  // IEEE 754 half precision
TYPE_FP32t   = 0x24  // tensor float 32
TYPE_FP32    = 0x25  // IEEE 754 single precision
TYPE_FP64    = 0x26  // IEEE 754 double precision
TYPE_FP80    = 0x27  // x87 extended precision
TYPE_FP128   = 0x28  // IEEE 754 quadruple precision

// Fixed Width Vectors
TYPE_V128 = 0x30  // 128-bit vector
TYPE_V256 = 0x31  // 256-bit vector
TYPE_V512 = 0x32  // 512-bit vector

// Optimizable types
TYPE_BIT = 0x40  // 1-bit boolean

// COIL Special Types
TYPE_VAR = 0x90  // Value is a variable ID
TYPE_SYM = 0x91  // Value is a symbol rather than value at symbol
TYPE_RGP = 0x92  // Register general purpose
TYPE_RFP = 0x93  // Register floating point
TYPE_RV  = 0x94  // Register vector
TYPE_RS  = 0x95  // Register segment
TYPE_SAR = 0x96  // State - all registers
TYPE_SAF = 0x97  // State - all flags
TYPE_SES = 0x98  // State - extended processor state
TYPE_SS  = 0x99  // State - complete state
TYPE_IP  = 0x9A  // Register Instruction Pointer
TYPE_SP  = 0x9B  // Register Stack Pointer
TYPE_BP  = 0x9C  // Register Base Pointer

// Platform Dependent Types
TYPE_INT  = 0xA0  // Default integer for current platform
TYPE_UNT  = 0xA1  // Default unsigned for current platform
TYPE_FP   = 0xA2  // Default float for current platform
TYPE_LINT = 0xA3  // Largest integer for current platform
TYPE_LUNT = 0xA4  // Largest unsigned for current platform
TYPE_LFP  = 0xA5  // Largest float point for current platform
TYPE_PTR  = 0xA6  // Default pointer size for current platform

// Complex Types
TYPE_CINT = 0xB0  // Complex integer
TYPE_CUNT = 0xB1  // Complex unsigned
TYPE_CFP  = 0xB2  // Complex floating point

// Composite Types
TYPE_STRUCT = 0xD0  // Structure type
TYPE_PACK   = 0xD1  // Packed structure (no padding)
TYPE_UNION  = 0xD2  // Union type
TYPE_ARRAY  = 0xD3  // Array type

// Parameter Types
TYPE_PARAM5 = 0xF0  // Parameter type 5
TYPE_PARAM4 = 0xFA  // Parameter type 4
TYPE_PARAM3 = 0xFB  // Parameter type 3
TYPE_PARAM2 = 0xFC  // Parameter type 2
TYPE_PARAM1 = 0xFD  // Parameter type 1
TYPE_PARAM0 = 0xFE  // Parameter type 0

// Void Type
TYPE_VOID = 0xFF  // Void type (no value)
```

### 3.2 Type Extensions (Second 8 bits)

Type extensions provide additional qualifiers for type values:

```
TYPEEXT_CONST    = (1 << 0)  // 0x01 - Constant value (read-only)
TYPEEXT_VOLATILE = (1 << 1)  // 0x02 - Volatile access (not optimizable)
TYPEEXT_VOID     = (1 << 4)  // 0x10 - No type, just value
TYPEEXT_IMM      = (1 << 5)  // 0x20 - Immediate value
TYPEEXT_VAR      = (1 << 6)  // 0x40 - Variable reference
TYPEEXT_SYM      = (1 << 7)  // 0x80 - Symbol reference
```

### 3.3 Parameter Definitions

Parameters modify instruction behavior and provide additional context for operations.

#### 3.3.1 Branch Conditions
```
BRANCH_COND_EQ = 0x00  // Equal
BRANCH_COND_NE = 0x01  // Not equal
BRANCH_COND_GE = 0x02  // Greater than or equal
BRANCH_COND_LT = 0x03  // Less than
BRANCH_COND_GT = 0x04  // Greater than
BRANCH_COND_LE = 0x05  // Less than or equal
BRANCH_COND_Z  = 0x06  // Zero flag set
BRANCH_COND_NZ = 0x07  // Zero flag not set
BRANCH_COND_C  = 0x08  // Carry flag set
BRANCH_COND_NC = 0x09  // Carry flag not set
BRANCH_COND_O  = 0x0A  // Overflow flag set
BRANCH_COND_NO = 0x0B  // Overflow flag not set
BRANCH_COND_S  = 0x0C  // Sign flag set
BRANCH_COND_NS = 0x0D  // Sign flag not set
```

#### 3.3.2 Branch Control
```
BRANCH_CTRL_FAR       = 0x00  // Far jump/call
BRANCH_CTRL_INL       = 0x01  // Inline
BRANCH_CTRL_ABI       = 0x02  // Use ABI conventions
BRANCH_CTRL_ABI_PARAM = 0x03  // Following operands are parameters
BRANCH_CTRL_ABI_RET   = 0x04  // Following operands are return destinations
```

#### 3.3.3 Memory Control
```
MEMORY_CTRL_ATOMIC    = 0x01  // Atomic operation
MEMORY_CTRL_VOLATILE  = 0x02  // Volatile access
MEMORY_CTRL_ALIGNED   = 0x03  // Enforce alignment
MEMORY_CTRL_UNALIGNED = 0x04  // Allow unaligned access
```

## 4. Register System

COIL uses a platform-specific register model that gives direct access to hardware registers when needed, while providing a consistent access pattern across architectures. Register references in the binary format include:

1. General Purpose Registers (TYPE_RGP + index)
2. Floating Point Registers (TYPE_RFP + index)
3. Vector Registers (TYPE_RV + index)
4. Special Registers (TYPE_RS, TYPE_IP, TYPE_SP, etc.)

For cross-platform code, the variable system should be used instead of direct register manipulation. The ABI parameter types (BRANCH_CTRL_ABI*) provide automatic mapping between variables and appropriate ABI registers.

### 4.1 Register Operand Encoding

When a register is used as an operand, it's encoded as:

```
[type: uint16_t][register: uint8_t]
```

Where type is one of:
- TYPE_RGP (0x92): General purpose register
- TYPE_RFP (0x93): Floating point register
- TYPE_RV (0x94): Vector register
- TYPE_RS (0x95): Segment register
- TYPE_IP (0x9A): Instruction pointer
- TYPE_SP (0x9B): Stack pointer
- TYPE_BP (0x9C): Base/frame pointer

The register byte is interpreted according to the current platform context.

### 4.2 x86-64 Registers

Special registers are encoded with just the type to help with code size. Other registers are encoded with the TYPE_RGP followed by a register identifier.

#### 4.2.1 Special x86-64 Registers
```
bp/ebp/rbp = TYPE_BP
sp/esp/rsp = TYPE_SP
ip/eip/rip = TYPE_IP
```

#### 4.2.2 x86-64 General Purpose Registers (TYPE_RGP)

##### 8-bit Registers
```
al   = 0x00
bl   = 0x01
cl   = 0x02
dl   = 0x03
sil  = 0x04
dil  = 0x05
r8b  = 0x06
r9b  = 0x07
r10b = 0x08
r11b = 0x09
r12b = 0x0A
r13b = 0x0B
r14b = 0x0C
r15b = 0x0D
```

##### 16-bit Registers
```
ax   = 0x0E
bx   = 0x0F
cx   = 0x10
dx   = 0x11
si   = 0x12
di   = 0x13
r8w  = 0x14
r9w  = 0x15
r10w = 0x16
r11w = 0x17
r12w = 0x18
r13w = 0x19
r14w = 0x1A
r15w = 0x1B
```

##### 32-bit Registers
```
eax  = 0x1C
ebx  = 0x1D
ecx  = 0x1E
edx  = 0x1F
esi  = 0x20
edi  = 0x21
r8d  = 0x22
r9d  = 0x23
r10d = 0x24
r11d = 0x25
r12d = 0x26
r13d = 0x27
r14d = 0x28
r15d = 0x29
```

##### 64-bit Registers
```
rax  = 0x2A
rbx  = 0x2B
rcx  = 0x2C
rdx  = 0x2D
rsi  = 0x2E
rdi  = 0x2F
r8   = 0x30
r9   = 0x31
r10  = 0x32
r11  = 0x33
r12  = 0x34
r13  = 0x35
r14  = 0x36
r15  = 0x37
```

#### 4.2.3 x86-64 Floating Point Registers (TYPE_RFP)

##### Legacy x87 FPU Registers
```
ST0 = 0x00
ST1 = 0x01
ST2 = 0x02
ST3 = 0x03
ST4 = 0x04
ST5 = 0x05
ST6 = 0x06
ST7 = 0x07
```

##### SSE/AVX 128-bit Registers
```
XMM0  = 0x10
XMM1  = 0x11
XMM2  = 0x12
XMM3  = 0x13
XMM4  = 0x14
XMM5  = 0x15
XMM6  = 0x16
XMM7  = 0x17
XMM8  = 0x18
XMM9  = 0x19
XMM10 = 0x1A
XMM11 = 0x1B
XMM12 = 0x1C
XMM13 = 0x1D
XMM14 = 0x1E
XMM15 = 0x1F
```

#### 4.2.4 x86-64 Vector Registers (TYPE_RV)

##### AVX 256-bit Registers
```
YMM0  = 0x00
YMM1  = 0x01
YMM2  = 0x02
YMM3  = 0x03
YMM4  = 0x04
YMM5  = 0x05
YMM6  = 0x06
YMM7  = 0x07
YMM8  = 0x08
YMM9  = 0x09
YMM10 = 0x0A
YMM11 = 0x0B
YMM12 = 0x0C
YMM13 = 0x0D
YMM14 = 0x0E
YMM15 = 0x0F
```

##### AVX-512 512-bit Registers
```
ZMM0  = 0x10
ZMM1  = 0x11
ZMM2  = 0x12
ZMM3  = 0x13
ZMM4  = 0x14
ZMM5  = 0x15
ZMM6  = 0x16
ZMM7  = 0x17
ZMM8  = 0x18
ZMM9  = 0x19
ZMM10 = 0x1A
ZMM11 = 0x1B
ZMM12 = 0x1C
ZMM13 = 0x1D
ZMM14 = 0x1E
ZMM15 = 0x1F
ZMM16 = 0x20
ZMM17 = 0x21
ZMM18 = 0x22
ZMM19 = 0x23
ZMM20 = 0x24
ZMM21 = 0x25
ZMM22 = 0x26
ZMM23 = 0x27
ZMM24 = 0x28
ZMM25 = 0x29
ZMM26 = 0x2A
ZMM27 = 0x2B
ZMM28 = 0x2C
ZMM29 = 0x2D
ZMM30 = 0x2E
ZMM31 = 0x2F
```

#### 4.2.5 x86-64 Segment Registers (TYPE_RS)
```
CS = 0x00
DS = 0x01
ES = 0x02
FS = 0x03
GS = 0x04
SS = 0x05
```

### 4.3 ARM64 Registers

#### 4.3.1 ARM64 General Purpose Registers (TYPE_RGP)

##### 64-bit General Purpose
```
X0  = 0x00  // Parameter/Result
X1  = 0x01  // Parameter/Result
X2  = 0x02  // Parameter
X3  = 0x03  // Parameter
X4  = 0x04  // Parameter
X5  = 0x05  // Parameter
X6  = 0x06  // Parameter
X7  = 0x07  // Parameter
X8  = 0x08  // Indirect result location
X9  = 0x09  // Temporary
X10 = 0x0A  // Temporary
X11 = 0x0B  // Temporary
X12 = 0x0C  // Temporary
X13 = 0x0D  // Temporary
X14 = 0x0E  // Temporary
X15 = 0x0F  // Temporary
X16 = 0x10  // IP0 (Intra-procedure-call)
X17 = 0x11  // IP1 (Intra-procedure-call)
X18 = 0x12  // Platform register
X19 = 0x13  // Callee-saved
X20 = 0x14  // Callee-saved
X21 = 0x15  // Callee-saved
X22 = 0x16  // Callee-saved
X23 = 0x17  // Callee-saved
X24 = 0x18  // Callee-saved
X25 = 0x19  // Callee-saved
X26 = 0x1A  // Callee-saved
X27 = 0x1B  // Callee-saved
X28 = 0x1C  // Callee-saved
X29 = 0x1D  // Frame pointer
X30 = 0x1E  // Link register
```

##### 32-bit General Purpose (W0-W30 are lower 32 bits of X0-X30)
```
W0  = 0x40
W1  = 0x41
// ... and so on through W30 = 0x5E
```

#### 4.3.2 ARM64 Special Registers
```
// Already defined special types can be used
SP = TYPE_SP  // Stack pointer (X31)
PC = TYPE_IP  // Program counter
```

#### 4.3.3 ARM64 SIMD/Vector Registers (TYPE_RV)
```
V0  = 0x00
V1  = 0x01
V2  = 0x02
V3  = 0x03
V4  = 0x04
V5  = 0x05
V6  = 0x06
V7  = 0x07
V8  = 0x08
V9  = 0x09
V10 = 0x0A
V11 = 0x0B
V12 = 0x0C
V13 = 0x0D
V14 = 0x0E
V15 = 0x0F
V16 = 0x10
V17 = 0x11
V18 = 0x12
V19 = 0x13
V20 = 0x14
V21 = 0x15
V22 = 0x16
V23 = 0x17
V24 = 0x18
V25 = 0x19
V26 = 0x1A
V27 = 0x1B
V28 = 0x1C
V29 = 0x1D
V30 = 0x1E
V31 = 0x1F
```

### 4.4 RISC-V Registers

#### 4.4.1 RISC-V General Purpose Registers (TYPE_RGP)
```
X0  = 0x00  // Zero register (hardwired to 0)
X1  = 0x01  // Return address (ra)
X2  = 0x02  // Stack pointer (sp)
X3  = 0x03  // Global pointer (gp)
X4  = 0x04  // Thread pointer (tp)
X5  = 0x05  // Temporary (t0)
X6  = 0x06  // Temporary (t1)
X7  = 0x07  // Temporary (t2)
X8  = 0x08  // Saved register/frame pointer (s0/fp)
X9  = 0x09  // Saved register (s1)
X10 = 0x0A  // Function argument/return value (a0)
X11 = 0x0B  // Function argument/return value (a1)
X12 = 0x0C  // Function argument (a2)
X13 = 0x0D  // Function argument (a3)
X14 = 0x0E  // Function argument (a4)
X15 = 0x0F  // Function argument (a5)
X16 = 0x10  // Function argument (a6)
X17 = 0x11  // Function argument (a7)
X18 = 0x12  // Saved register (s2)
X19 = 0x13  // Saved register (s3)
X20 = 0x14  // Saved register (s4)
X21 = 0x15  // Saved register (s5)
X22 = 0x16  // Saved register (s6)
X23 = 0x17  // Saved register (s7)
X24 = 0x18  // Saved register (s8)
X25 = 0x19  // Saved register (s9)
X26 = 0x1A  // Saved register (s10)
X27 = 0x1B  // Saved register (s11)
X28 = 0x1C  // Temporary (t3)
X29 = 0x1D  // Temporary (t4)
X30 = 0x1E  // Temporary (t5)
X31 = 0x1F  // Temporary (t6)
```

#### 4.4.2 RISC-V Floating Point Registers (TYPE_RFP)
```
F0  = 0x00  // FP temporary (ft0)
F1  = 0x01  // FP temporary (ft1)
F2  = 0x02  // FP temporary (ft2)
F3  = 0x03  // FP temporary (ft3)
F4  = 0x04  // FP temporary (ft4)
F5  = 0x05  // FP temporary (ft5)
F6  = 0x06  // FP temporary (ft6)
F7  = 0x07  // FP temporary (ft7)
F8  = 0x08  // FP saved register (fs0)
F9  = 0x09  // FP saved register (fs1)
F10 = 0x0A  // FP argument/return value (fa0)
F11 = 0x0B  // FP argument/return value (fa1)
F12 = 0x0C  // FP argument (fa2)
F13 = 0x0D  // FP argument (fa3)
F14 = 0x0E  // FP argument (fa4)
F15 = 0x0F  // FP argument (fa5)
F16 = 0x10  // FP argument (fa6)
F17 = 0x11  // FP argument (fa7)
F18 = 0x12  // FP saved register (fs2)
F19 = 0x13  // FP saved register (fs3)
F20 = 0x14  // FP saved register (fs4)
F21 = 0x15  // FP saved register (fs5)
F22 = 0x16  // FP saved register (fs6)
F23 = 0x17  // FP saved register (fs7)
F24 = 0x18  // FP saved register (fs8)
F25 = 0x19  // FP saved register (fs9)
F26 = 0x1A  // FP saved register (fs10)
F27 = 0x1B  // FP saved register (fs11)
F28 = 0x1C  // FP temporary (ft8)
F29 = 0x1D  // FP temporary (ft9)
F30 = 0x1E  // FP temporary (ft10)
F31 = 0x1F  // FP temporary (ft11)
```

### 4.5 ABI Register Mapping

When BRANCH_CTRL_ABI is used, the following register mappings apply based on platform:

#### 4.5.1 C ABI x86-64
- Return value: RAX (R0, 0x2A)
- Parameters: RDI, RSI, RDX, RCX, R8, R9 (in order)
- Preserved: RBX, RBP, RSP, R12-R15

#### 4.5.2 C ABI ARM64
- Return value: X0 (0x00)
- Parameters: X0-X7 (in order)
- Preserved: X19-X29, SP

#### 4.5.3 C ABI RISC-V64
- Return value: X10 (a0, 0x0A)
- Parameters: X10-X17 (a0-a7, in order)
- Preserved: X8, X9, X18-X27 (s0-s11)

## 5. Instruction Set

The COIL instruction set is organized by functional categories. Each instruction includes its opcode, description, and operand requirements.

### 5.1 No Operation

#### NOP (0x00)
No Operation - Does nothing, advances instruction pointer.

Format: Single byte with value 0x00 (no operands)

### 5.2 Control Flow Instructions (0x01-0x2F)

#### JMP (0x01)
Update instruction pointer to address.

```
Operands:
- Target: TYPE_RGP | TYPE_PTR | TYPE_SYM | TYPE_*UNT*
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

#### CALL (0x02)
Update instruction pointer to address and store calling instruction next address.

```
Operands:
- Target: TYPE_RGP | TYPE_PTR | TYPE_SYM | TYPE_*UNT*
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

Example of CALL with ABI:
```
0x02 (CALL)
0x06 (6 Operands)
  [type: TYPE_SYM][symbol_table_id: UINT] (function name through symbol table)
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI] (use ABI conventions)
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI_PARAM] (following are parameters)
  [type: TYPE_INT8 | TYPEEXT_IMM][data: immediate 8-bit signed integer]
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI_RET] (following is return value)
  [type: TYPE_INT8 | TYPEEXT_VAR][data: variable id for return value]
```

#### RET (0x03)
Return from procedure.

```
Operands:
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

#### INT (0x04)
Software interrupt.

```
Operands:
- Interrupt: TYPE_*UNT*
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

#### SYSC (0x05)
System call - special software interrupt for OS communication.

```
Operands:
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

#### IRET (0x06)
Return from software interrupt procedure.

```
Operands:
- TYPE_PARAM0: branch_condition_t (optional)
- TYPE_PARAM1: branch_ctrl_t (optional)
```

### 5.3 Memory Operations (0x30-0x4F)

#### MOV (0x30)
Move data between registers or memory locations.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- TYPE_PARAM0: branch_condition_t (optional)
```

Example (x86-64):
```
MOV RAX, RBX:
0x30 (MOV)
0x02 (2 operands)
  [type: TYPE_RGP][register: 0x2A] (RAX)
  [type: TYPE_RGP][register: 0x2B] (RBX)
```

#### STORE (0x31)
Store register value to memory.

```
Operands:
- Source: TYPE_RGP | TYPE_RFP | TYPE_RV | TYPE_SAR | TYPE_SAF | TYPE_SS | TYPE_RS
- Destination: TYPE_PTR
- TYPE_PARAM0: branch_condition_t (optional)
```

#### LOAD (0x32)
Load register value from memory.

```
Operands:
- Destination: TYPE_RGP | TYPE_RFP | TYPE_RV | TYPE_SAR | TYPE_SAF | TYPE_SS | TYPE_RS
- Source: TYPE_PTR
- TYPE_PARAM0: branch_condition_t (optional)
```

#### PUSH (0x33)
Push value onto stack.

```
Operands:
- Source: Non TYPE_VOID
- TYPE_PARAM0: branch_condition_t (optional)
```

#### POP (0x34)
Pop value from stack.

```
Operands:
- Destination: Non TYPE_VOID
- TYPE_PARAM0: branch_condition_t (optional)
```

#### LEA (0x35)
Load effective address.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_RGP | TYPE_PTR | TYPE_SYM | TYPE_*UNT*
- TYPE_PARAM0: branch_condition_t (optional)
```

#### SCOPE_BEGIN (0x36)
Begin a new variable scope. On exit, release used stack and free registers used by variables.

No arguments.

#### SCOPE_END (0x37)
End current variable scope. Release used stack and free registers used by variables.

No arguments.

#### VAR_DECL (0x38)
Declare typed variable in current scope.

```
Operands:
- Source: Non TYPE_VOID (can use TYPEEXT_VOID to initialize with type but no value)
```

#### REF (0x39)
Get reference to variable.

```
Operands:
- Source: TYPE_VAR
```

#### DEREF (0x3A)
Dereference a pointer.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_PTR
```

#### FENCE (0x3F)
Memory fence/barrier for synchronization.

No operands.

#### MEMCPY (0x40)
Copy memory block.

```
Operands:
- Destination: TYPE_PTR
- Source: TYPE_PTR
- Length: TYPE_*UNT*
```

#### MEMSET (0x41)
Set memory block to value.

```
Operands:
- Destination: TYPE_PTR
- Value: TYPE_*UNT*
- Length: TYPE_*UNT*
```

#### MEMCMP (0x42)
Compare memory blocks.

```
Operands:
- First: TYPE_PTR
- Second: TYPE_PTR
- Length: TYPE_*UNT*
```

#### XCHG (0x43)
Exchange value between registers or memory.

```
Operands:
- First: TYPE_RGP | TYPE_RFP | TYPE_VAR
- Second: TYPE_RGP | TYPE_RFP | TYPE_VAR
```

Example (x86-64):
```
XCHG RAX, RBX:
0x43 (XCHG)
0x02 (2 operands)
  [type: TYPE_RGP][register: 0x2A] (RAX)
  [type: TYPE_RGP][register: 0x2B] (RBX)
```

#### CAS (0x44)
Compare and swap (atomic).

```
Operands:
- Destination: Non TYPE_VOID
- Expected: Non TYPE_VOID
- New Value: Non TYPE_VOID
```

#### VARADDR (0x45)
Get address of variable.

```
Operands:
- Destination: TYPE_PTR
- Source: TYPE_VAR
```

#### PIN (0x46)
Pin memory for DMA operations.

```
Operands:
- Address: TYPE_PTR
- Size: TYPE_*UNT*
```

#### UNPIN (0x47)
Unpin memory after DMA operations.

```
Operands:
- Address: TYPE_PTR
```

### 5.4 Arithmetic Operations (0x50-0x5F)

#### ADD (0x50)
Addition.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

Example (ARM64):
```
ADD X0, X1, X2:
0x50 (ADD)
0x03 (3 operands)
  [type: TYPE_RGP][register: 0x00] (X0)
  [type: TYPE_RGP][register: 0x01] (X1)
  [type: TYPE_RGP][register: 0x02] (X2)
```

#### SUB (0x51)
Subtraction.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### MUL (0x52)
Multiplication.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

Example (RISC-V):
```
FMUL.D F10, F11, F12:
0x52 (MUL)
0x03 (3 operands)
  [type: TYPE_RFP][register: 0x0A] (F10)
  [type: TYPE_RFP][register: 0x0B] (F11)
  [type: TYPE_RFP][register: 0x0C] (F12)
```

#### DIV (0x53)
Division.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### MOD (0x54)
Modulus.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### NEG (0x55)
Negate (flip sign).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### ABS (0x56)
Absolute value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### INC (0x57)
Increment by 1.

```
Operands:
- Destination: Non TYPE_VOID
```

#### DEC (0x58)
Decrement by 1.

```
Operands:
- Destination: Non TYPE_VOID
```

#### ADC (0x59)
Add with carry.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### SBB (0x5A)
Subtract with borrow.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### SIGN (0x5B)
Extract sign of value (returns -1, 0, or 1).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### FMA (0x5C)
Fused multiply-add (a*b + c with single rounding).

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID (a)
- Source2: Non TYPE_VOID (b)
- Source3: Non TYPE_VOID (c)
```

#### MULH (0x5D)
Multiply high (return upper half of product).

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID
```

#### SEXT (0x5E)
Sign-extend value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

### 5.5 Bit Manipulation Operations (0x60-0x6F)

#### AND (0x60)
Bitwise AND.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### OR (0x61)
Bitwise OR.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### XOR (0x62)
Bitwise XOR (exclusive OR).

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### NOT (0x63)
Bitwise NOT (complement).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID (optional - if not provided, modifies destination)
```

#### SHL (0x64)
Shift left (logical).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### SHR (0x65)
Shift right (logical).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### SAL (0x66)
Shift arithmetic left.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### SAR (0x67)
Shift arithmetic right (preserves sign).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### ROL (0x68)
Rotate left.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### ROR (0x69)
Rotate right.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Count: TYPE_*UNT*
```

#### PCNT (0x6A)
Population count (count number of bits set to 1).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### LZC (0x6B)
Leading zero count.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### TZC (0x6C)
Trailing zero count.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### BRV (0x6D)
Bit reversal (reverse bit order).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### BSWAP (0x6F)
Byte swap (reverse byte order).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

### 5.6 Reserved (0x70-0x7F)

Reserved for future expansion.

### 5.7 Advanced Arithmetic Operations (0x80-0x9F)

#### SQRT (0x80)
Square root.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### RSQRT (0x81)
Reciprocal square root (1/âˆšx).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### POW (0x82)
Power function (x^y).

```
Operands:
- Destination: Non TYPE_VOID
- Base: Non TYPE_VOID
- Exponent: Non TYPE_VOID
```

#### LOG (0x83)
Natural logarithm (base e).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### LOG2 (0x84)
Base-2 logarithm.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### LOG10 (0x85)
Base-10 logarithm.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### EXP (0x86)
Exponential function (e^x).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### EXP2 (0x87)
Base-2 exponential (2^x).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### SIN (0x88)
Sine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### COS (0x89)
Cosine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### TAN (0x8A)
Tangent.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### SINCOS (0x8B)
Sine and cosine simultaneously.

```
Operands:
- SinDestination: Non TYPE_VOID
- CosDestination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### ASIN (0x8C)
Arcsine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### ACOS (0x8D)
Arccosine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### ATAN (0x8E)
Arctangent.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### ATAN2 (0x8F)
2-argument arctangent (angle from x-axis to point).

```
Operands:
- Destination: Non TYPE_VOID
- Y: Non TYPE_VOID
- X: Non TYPE_VOID
```

#### SINH (0x90)
Hyperbolic sine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### COSH (0x91)
Hyperbolic cosine.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### TANH (0x92)
Hyperbolic tangent.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### CEIL (0x93)
Ceiling function (round up).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### FLOOR (0x94)
Floor function (round down).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### ROUND (0x95)
Round to nearest integer.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### TRUNC (0x96)
Truncate (remove fractional part).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### FRACT (0x97)
Extract fractional part.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### MIN (0x98)
Minimum of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID
```

#### MAX (0x99)
Maximum of two values.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: Non TYPE_VOID
- Source2: Non TYPE_VOID
```

#### CLAMP (0x9A)
Clamp value between min and max.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
- Min: Non TYPE_VOID
- Max: Non TYPE_VOID
```

#### LERP (0x9B)
Linear interpolation.

```
Operands:
- Destination: Non TYPE_VOID
- Start: Non TYPE_VOID
- End: Non TYPE_VOID
- Factor: Non TYPE_VOID (floating point type, 0.0-1.0)
```

#### COPYSIGN (0x9C)
Copy sign from one value to another.

```
Operands:
- Destination: Non TYPE_VOID
- Value: Non TYPE_VOID
- Sign: Non TYPE_VOID
```

### 5.8 Logical Operations (0xA0-0xA1)

#### CMP (0xA0)
Compare values and set flags without changing registers.

```
Operands:
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
```

#### TEST (0xA1)
Bitwise AND and set flags without changing registers.

```
Operands:
- Left: Non TYPE_VOID
- Right: Non TYPE_VOID
```

### 5.9 Array/Vector Operations (0xA2-0xBF)

#### SCATTER (0xA2)
Scatter elements from a vector to non-contiguous memory locations.

```
Operands:
- Source: TYPE_V*
- Indices: TYPE_V*
- Base: TYPE_PTR
```

#### GATHER (0xA3)
Gather elements from non-contiguous memory locations into a vector.

```
Operands:
- Destination: TYPE_V*
- Indices: TYPE_V*
- Base: TYPE_PTR
```

#### REDUCE_SUM (0xA4)
Vector reduction to sum.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_V*
```

#### REDUCE_MAX (0xA5)
Vector reduction to maximum value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_V*
```

#### REDUCE_MIN (0xA6)
Vector reduction to minimum value.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_V*
```

#### SHUFFLE (0xA7)
Reorder vector elements based on an index vector.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Indices: TYPE_V*
```

#### BROADCAST (0xA8)
Replicate a scalar value across a vector.

```
Operands:
- Destination: TYPE_V*
- Source: Non TYPE_VOID
```

#### COMPRESS (0xA9)
Compress a vector by removing elements based on a mask.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Mask: TYPE_V*
```

#### EXPAND (0xAA)
Expand a vector by inserting elements based on a mask.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Mask: TYPE_V*
```

#### PERMUTE (0xAB)
Permute vector elements with a fixed pattern.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Pattern: TYPE_V*
```

#### INTERLEAVE (0xAC)
Interleave elements from two vectors.

```
Operands:
- Destination: TYPE_V*
- Source1: TYPE_V*
- Source2: TYPE_V*
```

#### DEINTERLEAVE (0xAD)
Separate interleaved vector elements.

```
Operands:
- Destination1: TYPE_V*
- Destination2: TYPE_V*
- Source: TYPE_V*
```

#### DOT (0xB0)
Vector dot product.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: TYPE_V*
- Source2: TYPE_V*
```

#### CROSS (0xB1)
Vector cross product.

```
Operands:
- Destination: TYPE_V*
- Source1: TYPE_V*
- Source2: TYPE_V*
```

#### NORM (0xB3)
Vector normalization.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
```

#### DIST (0xB4)
Distance between vectors.

```
Operands:
- Destination: Non TYPE_VOID
- Source1: TYPE_V*
- Source2: TYPE_V*
```

#### PACK (0xB5)
Pack multiple elements into a vector.

```
Operands:
- Destination: TYPE_V*
- [Multiple source elements]
```

#### UNPACK (0xB6)
Unpack vector into multiple elements.

```
Operands:
- [Multiple destination elements]
- Source: TYPE_V*
```

#### MASK_LOAD (0xB7)
Load vector elements conditionally based on mask.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_PTR
- Mask: TYPE_V*
```

#### MASK_STORE (0xB8)
Store vector elements conditionally based on mask.

```
Operands:
- Destination: TYPE_PTR
- Source: TYPE_V*
- Mask: TYPE_V*
```

#### SEL (0xB9)
Select between two vectors based on condition mask.

```
Operands:
- Destination: TYPE_V*
- True Source: TYPE_V*
- False Source: TYPE_V*
- Mask: TYPE_V*
```

#### EXTRACT (0xBA)
Extract element from vector.

```
Operands:
- Destination: Non TYPE_VOID
- Source: TYPE_V*
- Index: TYPE_*UNT*
```

#### INSERT (0xBB)
Insert element into vector.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Value: Non TYPE_VOID
- Index: TYPE_*UNT*
```

#### TRANSPOSE (0xBD)
Matrix transpose.

```
Operands:
- Destination: TYPE_V*
- Source: TYPE_V*
- Rows: TYPE_*UNT*
- Columns: TYPE_*UNT*
```

#### MATMUL (0xBE)
Matrix multiplication.

```
Operands:
- Destination: TYPE_V*
- LeftMatrix: TYPE_V*
- RightMatrix: TYPE_V*
- LeftRows: TYPE_*UNT*
- LeftCols: TYPE_*UNT*
- RightCols: TYPE_*UNT*
```

### 5.10 Type Operations (0xC0-0xCF)

#### CONVERT (0xC0)
Type conversion between different numeric representations.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### BITCAST (0xC1)
Reinterpret bits as a different type without changing bit pattern.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### PROMOTE (0xC2)
Promote to a wider type (e.g., 32-bit to 64-bit).

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### DEMOTE (0xC3)
Demote to a narrower type.

```
Operands:
- Destination: Non TYPE_VOID
- Source: Non TYPE_VOID
```

#### CHECK_OVERFLOW (0xC4)
Check and handle numeric overflow.

```
Operands:
- Value: Non TYPE_VOID
- Handler: TYPE_PTR (optional)
```

#### CHECK_UNDERFLOW (0xC5)
Check and handle numeric underflow.

```
Operands:
- Value: Non TYPE_VOID
- Handler: TYPE_PTR (optional)
```

#### IS_NAN (0xC6)
Check if value is Not-a-Number.

```
Operands:
- Destination: TYPE_BIT
- Source: Non TYPE_VOID
```

#### IS_INF (0xC7)
Check if value is infinity.

```
Operands:
- Destination: TYPE_BIT
- Source: Non TYPE_VOID
```

#### IS_FINITE (0xC8)
Check if value is finite.

```
Operands:
- Destination: TYPE_BIT
- Source: Non TYPE_VOID
```

#### TYPE_SIZE (0xC9)
Get size of a type.

```
Operands:
- Destination: TYPE_*UNT*
- Type: TYPE_*
```

#### TYPE_ALIGN (0xCA)
Get alignment requirement of a type.

```
Operands:
- Destination: TYPE_*UNT*
- Type: TYPE_*
```

#### TYPEOF (0xCB)
Get type information for a value.

```
Operands:
- Destination: TYPE_*UNT*
- Source: Non TYPE_VOID
```

#### ISINSTANCE (0xCC)
Check if value is of specified type.

```
Operands:
- Destination: TYPE_BIT
- Source: Non TYPE_VOID
- Type: TYPE_*
```

### 5.11 Processor Unit Specific (0xD0-0xDF)

#### CPUID (0xD0)
Get CPU identification and feature information.

```
Operands:
- Function: TYPE_*UNT*
- [Optional additional operands based on function]
```

#### RDTSC (0xD1)
Read timestamp counter.

```
Operands:
- Destination: TYPE_*UNT*
```

#### CLI (0xD2)
Clear interrupt flag (disable interrupts).

No operands.

#### STI (0xD3)
Set interrupt flag (enable interrupts).

No operands.

#### HLT (0xD4)
Halt processor.

No operands.

#### PAUSE (0xD5)
Spin-wait hint.

No operands.

#### IN (0xD6)
Input from port.

```
Operands:
- Destination: Non TYPE_VOID
- Port: TYPE_*UNT*
```

#### OUT (0xD7)
Output to port.

```
Operands:
- Port: TYPE_*UNT*
- Value: Non TYPE_VOID
```

#### RDMSR (0xD8)
Read from model-specific register.

```
Operands:
- Destination: TYPE_*UNT*
- Register: TYPE_*UNT*
```

#### WRMSR (0xD9)
Write to model-specific register.

```
Operands:
- Register: TYPE_*UNT*
- Value: TYPE_*UNT*
```

#### INVD (0xDA)
Invalidate cache.

No operands.

#### WBINVD (0xDB)
Write back and invalidate cache.

No operands.

#### CLFLUSH (0xDC)
Flush cache line.

```
Operands:
- Address: TYPE_PTR
```

### 5.12 Directives (0xE0-0xEF)

#### ALIGN (0xE0)
Align code or data to boundary.

```
Operands:
- Alignment: TYPE_*UNT*
```

#### SECTION (0xE1)
Define a new section.

```
Operands:
- Name: TYPE_SYM
- Attributes: TYPE_*UNT* (optional)
```

#### GLOBAL (0xE2)
Define global symbol.

```
Operands:
- Symbol: TYPE_SYM
- Type: TYPE_* (optional)
```

#### EXTERN (0xE3)
Declare external symbol.

```
Operands:
- Symbol: TYPE_SYM
- Type: TYPE_* (optional)
```

#### DATA (0xE4)
Define data / Insert bytes.

```
Operands:
- [Multiple data values]
```

#### CONST (0xE5)
Define constant.

```
Operands:
- Name: TYPE_SYM
- Value: Non TYPE_VOID
```

#### STRUCT (0xE6)
Define structure type.

```
Operands:
- Name: TYPE_SYM
- [Multiple field definitions]
```

#### ENUM (0xE7)
Define enumeration.

```
Operands:
- Name: TYPE_SYM
- [Multiple value definitions]
```

#### TYPEDEF (0xE8)
Define type alias.

```
Operands:
- Name: TYPE_SYM
- Type: TYPE_*
```

#### MACRO (0xE9)
Define macro.

```
Operands:
- Name: TYPE_SYM
- [Parameter definitions]
```

#### ENDMACRO (0xEA)
End macro definition.

No operands.

#### IF (0xEB)
Conditional assembly if.

```
Operands:
- Condition: Non TYPE_VOID
```

#### ELSE (0xEC)
Conditional assembly else.

No operands.

#### ENDIF (0xED)
End conditional assembly.

No operands.

### 5.13 COIL Processor Specific (0xF0-0xFF)

This range is reserved for COIL processor-specific extensions. Implementations may define custom instructions in this range.

## 6. Implementation Guidelines

### 6.1 Type Inference

The COIL ISA relies heavily on type inference to determine instruction behavior:

1. First check for parameter types (0xFA-0xFE) to identify instruction modifiers
2. For operations with multiple operands, the first non-parameter operand typically defines the destination
3. Use the widest type among operands when performing operations on mixed types
4. Respect explicit type qualifiers (TYPEEXT_*) when present

### 6.2 Instruction Encoding

For compact encoding:

1. Single-byte opcodes (0x00-0xFF) identify the instruction
2. For instructions with operands, the second byte contains the operand count
3. Each operand consists of a type field (uint16_t) followed by variable-length data
4. The type field encodes both the main type (first 8 bits) and type extensions (second 8 bits)

### 6.3 Memory Management

1. SCOPE_BEGIN and SCOPE_END instructions define variable lifetimes
2. Variable declarations within a scope are automatically managed
3. Memory fences (FENCE) provide synchronization primitives
4. PIN/UNPIN allow control over memory for DMA operations

### 6.4 Processing Unit Integration

1. The range 0xD0-0xDF provides processor-specific operations
2. The range 0xF0-0xFF is reserved for extensions specific to COIL processors
3. Instructions like CPUID, RDTSC, etc. allow interaction with the underlying hardware

### 6.5 ABI Considerations

1. BRANCH_CTRL_ABI* parameters allow for platform-specific calling conventions
2. When BRANCH_CTRL_ABI_PARAM is used, subsequent operands are treated as parameters
3. When BRANCH_CTRL_ABI_RET is used, subsequent operands are treated as return destinations

### 6.6 Error Handling

Implementations should define behavior for:

1. Type mismatches between operands
2. Invalid operand combinations
3. Out-of-bounds memory access
4. Division by zero and other arithmetic exceptions
5. Invalid instruction encodings

The CHECK_OVERFLOW and CHECK_UNDERFLOW instructions provide explicit mechanisms for handling numeric exceptions.

## 7. Register Usage Examples

### Example 1: x86-64 Register Move
```
MOV RAX, RBX:
0x30 (MOV)
0x02 (2 operands)
  [type: TYPE_RGP][register: 0x2A] (RAX)
  [type: TYPE_RGP][register: 0x2B] (RBX)
```

### Example 2: ARM64 64-bit Add
```
ADD X0, X1, X2:
0x50 (ADD)
0x03 (3 operands)
  [type: TYPE_RGP][register: 0x00] (X0)
  [type: TYPE_RGP][register: 0x01] (X1)
  [type: TYPE_RGP][register: 0x02] (X2)
```

### Example 3: RISC-V Floating Point Operation
```
FMUL.D F10, F11, F12:
0x52 (MUL)
0x03 (3 operands)
  [type: TYPE_RFP][register: 0x0A] (F10)
  [type: TYPE_RFP][register: 0x0B] (F11)
  [type: TYPE_RFP][register: 0x0C] (F12)
```

### Example 4: Function Call with C ABI
```
// Call function "main" with one parameter, storing return value
0x02 (CALL)
0x06 (6 Operands)
  [type: TYPE_SYM][symbol_table_id: UINT] (symbol "main")
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI] (use C ABI conventions)
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI_PARAM] (following are parameters)
  [type: TYPE_INT8 | TYPEEXT_IMM][data: 42] (immediate value parameter)
  [type: TYPE_PARAM1][data: BRANCH_CTRL_ABI_RET] (following is return destination)
  [type: TYPE_INT32 | TYPEEXT_VAR][data: 1] (variable #1 for return value)
```