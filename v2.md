# COIL Instruction Set Architecture Specification (Version 2)

## Overview

The COIL (Compact Operation Instruction Language) Instruction Set Architecture defines a flexible binary instruction format designed for efficiency and portability across different processing units and architectures. COIL follows a type-determined instruction philosophy where behavior is inferred from operand types, enabling compact representation while maintaining expressive power.

COIL combines the advantages of a RISC-style instruction set with the expressiveness typically found in higher-level languages. It features a comprehensive type system, platform-independent variable abstraction, and direct access to hardware registers when needed.

COIL is built on the principle of "help, not block" - enabling developers to write code once and run it everywhere, while still providing full access to processing unit-specific features when needed. The architecture emulates missing capabilities when required but never restricts access to native functionality.

### Key Concepts Clarification

In COIL documentation:

- **Processing Unit**: The physical hardware device that executes instructions (CPU, GPU, FPGA, TPU, etc.). Each type of processing unit has fundamental differences in capabilities and design.

- **Architecture**: The instruction set architecture (ISA) that defines how software interfaces with a processing unit (x86, ARM, RISC-V, etc.).

- **Architecture Variant**: A specific implementation or generation of an architecture (x86-16, x86-64, ARM32, ARM64, etc.).

## 1. Instruction Format

Instructions in COIL follow a compact, variable-length format that minimizes code size while preserving flexibility:

```
No operand instruction:
[opcode: uint8_t]

Instruction with operands:
[opcode: uint8_t][operand_count: uint8_t][[operand: Operand]...]

Where Operand = [type: uint16_t][data: (type-dependent variable length)]
```

The type field (uint16_t) consists of two parts:
- Main type (first 8 bits): Describes the data width and operation type
- Extension bits (second 8 bits): Contains storage qualifiers and instruction modifiers

This encoding allows COIL to represent complex operations with minimal overhead, as the type system handles many of the details that would require separate opcodes in other architectures.

## 2. Processing Unit and Architecture Context

COIL uses a context specification to determine how instructions are interpreted and encoded. This context includes both the processing unit type and architecture variant, affecting register availability, instruction behavior, and native capabilities.

### 2.1 Processing Unit Types

```
PROCUNIT_CPU    = 0x01  // Central Processing Unit
PROCUNIT_GPU    = 0x02  // Graphics Processing Unit
PROCUNIT_TPU    = 0x03  // Tensor Processing Unit
PROCUNIT_DSP    = 0x04  // Digital Signal Processor
PROCUNIT_FPGA   = 0x05  // Field-Programmable Gate Array
PROCUNIT_NPU    = 0x06  // Neural Processing Unit
PROCUNIT_CUSTOM = 0xFE  // Custom processing unit
```

### 2.2 Architecture Variants

```
// CPU Architectures
ARCH_X86_16     = 0x01  // x86 16-bit (8086/8088)
ARCH_X86_32     = 0x02  // x86 32-bit (IA-32/i386)
ARCH_X86_64     = 0x03  // x86 64-bit (x86-64/AMD64)
ARCH_ARM32      = 0x04  // ARM 32-bit (AArch32)
ARCH_ARM64      = 0x05  // ARM 64-bit (AArch64)
ARCH_RISCV32    = 0x06  // RISC-V 32-bit
ARCH_RISCV64    = 0x07  // RISC-V 64-bit

// GPU Architectures
ARCH_NVIDIA_PTX = 0x20  // NVIDIA PTX ISA
ARCH_AMD_GCN    = 0x21  // AMD GCN ISA
ARCH_AMD_RDNA   = 0x22  // AMD RDNA ISA
ARCH_INTEL_XE   = 0x23  // Intel Xe ISA

// Generic/Cross-platform
ARCH_GENERIC    = 0xFF  // Generic architecture (fully portable)
```

### 2.3 Context Directives

COIL supports mixed processing unit and architecture programming through context directives:

```
SET_PROCUNIT [processing_unit_type]
SET_ARCH [architecture_variant]
```

These directives change the context for subsequent instructions, affecting register interpretation, instruction encoding, and available features. They enable different sections of code to target different processing units and architectures within the same file.

Example:
```
// Default context established in header

// Switch to x86-64 CPU-specific code
SET_PROCUNIT PROCUNIT_CPU
SET_ARCH ARCH_X86_64
// 64-bit x86 CPU optimized code here

// Switch to NVIDIA GPU code
SET_PROCUNIT PROCUNIT_GPU
SET_ARCH ARCH_NVIDIA_PTX
// NVIDIA GPU optimized code here

// Back to generic code that works everywhere
SET_PROCUNIT PROCUNIT_CPU
SET_ARCH ARCH_GENERIC
// Portable code here
```

### 2.4 Cross-Platform Principles

COIL's cross-platform approach is guided by these principles:

1. **Processing Unit Awareness**: COIL recognizes fundamental differences between processing units (e.g., CPUs have interrupts and privileged modes, GPUs have specialized thread models).

2. **Code Portability**: High-level COIL code using the variable system and architecture-agnostic instructions will run on any supported processing unit.

3. **Transparent Emulation**: When architecture-specific features are used but unavailable on a target, COIL will transparently emulate them when possible.

4. **Native Access**: Direct access to architecture-specific registers and instructions is always available without restrictions.

5. **No Intermediate Layers**: COIL assembles directly to the native machine code of the target processing unit and architecture.

## 3. Type System

The COIL type system is central to the architecture, allowing for precise control over data representation and operations. Types are encoded in 16 bits, with the first 8 bits representing the main type and the second 8 bits representing type extensions.

### 3.1 Main Types (First 8 bits)

```
// Fixed width signed integers
TYPE_INT8   = 0x01  // 8-bit signed integer
TYPE_INT16  = 0x02  // 16-bit signed integer
TYPE_INT32  = 0x03  // 32-bit signed integer
TYPE_INT64  = 0x04  // 64-bit signed integer
TYPE_INT128 = 0x05  // 128-bit signed integer

// Fixed width unsigned integers
TYPE_UNT8   = 0x10  // 8-bit unsigned integer
TYPE_UNT16  = 0x12  // 16-bit unsigned integer
TYPE_UNT32  = 0x13  // 32-bit unsigned integer
TYPE_UNT64  = 0x14  // 64-bit unsigned integer
TYPE_UNT128 = 0x15  // 128-bit unsigned integer
  
// Fixed width floating point
TYPE_FP8e5m2 = 0x20  // 8-bit float (5-bit exponent, 2-bit mantissa)
TYPE_FP8e4m3 = 0x21  // 8-bit float (4-bit exponent, 3-bit mantissa)
TYPE_FP16b   = 0x22  // bfloat16
TYPE_FP16    = 0x23  // IEEE 754 half precision
TYPE_FP32t   = 0x24  // tensor float 32
TYPE_FP32    = 0x25  // IEEE 754 single precision
TYPE_FP64    = 0x26  // IEEE 754 double precision
TYPE_FP80    = 0x27  // x87 extended precision
TYPE_FP128   = 0x28  // IEEE 754 quadruple precision

// Fixed Width Vectors
TYPE_V128 = 0x30  // 128-bit vector
TYPE_V256 = 0x31  // 256-bit vector
TYPE_V512 = 0x32  // 512-bit vector

// Optimizable types
TYPE_BIT = 0x40  // 1-bit boolean

// COIL Special Types
TYPE_VAR = 0x90  // Value is a variable ID
TYPE_SYM = 0x91  // Value is a symbol rather than value at symbol
TYPE_RGP = 0x92  // Register general purpose
TYPE_RFP = 0x93  // Register floating point
TYPE_RV  = 0x94  // Register vector
TYPE_RS  = 0x95  // Register segment
TYPE_SAR = 0x96  // State - all registers
TYPE_SAF = 0x97  // State - all flags
TYPE_SES = 0x98  // State - extended processor state
TYPE_SS  = 0x99  // State - complete state
TYPE_IP  = 0x9A  // Register Instruction Pointer
TYPE_SP  = 0x9B  // Register Stack Pointer
TYPE_BP  = 0x9C  // Register Base Pointer

// Platform Dependent Types
TYPE_INT  = 0xA0  // Default integer for current platform
TYPE_UNT  = 0xA1  // Default unsigned for current platform
TYPE_FP   = 0xA2  // Default float for current platform
TYPE_LINT = 0xA3  // Largest integer for current platform
TYPE_LUNT = 0xA4  // Largest unsigned for current platform
TYPE_LFP  = 0xA5  // Largest float point for current platform
TYPE_PTR  = 0xA6  // Default pointer size for current platform

// Complex Types
TYPE_CINT = 0xB0  // Complex integer
TYPE_CUNT = 0xB1  // Complex unsigned
TYPE_CFP  = 0xB2  // Complex floating point

// Composite Types
TYPE_STRUCT = 0xD0  // Structure type
TYPE_PACK   = 0xD1  // Packed structure (no padding)
TYPE_UNION  = 0xD2  // Union type
TYPE_ARRAY  = 0xD3  // Array type

// Parameter Types
TYPE_PARAM5 = 0xF0  // Parameter type 5
TYPE_PARAM4 = 0xFA  // Parameter type 4
TYPE_PARAM3 = 0xFB  // Parameter type 3
TYPE_PARAM2 = 0xFC  // Parameter type 2
TYPE_PARAM1 = 0xFD  // Parameter type 1
TYPE_PARAM0 = 0xFE  // Parameter type 0

// Void Type
TYPE_VOID = 0xFF  // Void type (no value)
```

### 3.2 Type Extensions (Second 8 bits)

Type extensions provide additional qualifiers for type values:

```
TYPEEXT_CONST    = (1 << 0)  // 0x01 - Constant value (read-only)
TYPEEXT_VOLATILE = (1 << 1)  // 0x02 - Volatile access (not optimizable)
TYPEEXT_VOID     = (1 << 4)  // 0x10 - No type, just value
TYPEEXT_IMM      = (1 << 5)  // 0x20 - Immediate value
TYPEEXT_VAR      = (1 << 6)  // 0x40 - Variable reference
TYPEEXT_SYM      = (1 << 7)  // 0x80 - Symbol reference
```

### 3.3 Parameter Definitions

Parameters modify instruction behavior and provide additional context for operations.

#### 3.3.1 Branch Conditions
```
BRANCH_COND_EQ = 0x00  // Equal
BRANCH_COND_NE = 0x01  // Not equal
BRANCH_COND_GE = 0x02  // Greater than or equal
BRANCH_COND_LT = 0x03  // Less than
BRANCH_COND_GT = 0x04  // Greater than
BRANCH_COND_LE = 0x05  // Less than or equal
BRANCH_COND_Z  = 0x06  // Zero flag set
BRANCH_COND_NZ = 0x07  // Zero flag not set
BRANCH_COND_C  = 0x08  // Carry flag set
BRANCH_COND_NC = 0x09  // Carry flag not set
BRANCH_COND_O  = 0x0A  // Overflow flag set
BRANCH_COND_NO = 0x0B  // Overflow flag not set
BRANCH_COND_S  = 0x0C  // Sign flag set
BRANCH_COND_NS = 0x0D  // Sign flag not set
```

#### 3.3.2 Branch Control
```
BRANCH_CTRL_FAR       = 0x00  // Far jump/call
BRANCH_CTRL_INL       = 0x01  // Inline
BRANCH_CTRL_ABI       = 0x02  // Use ABI conventions
BRANCH_CTRL_ABI_PARAM = 0x03  // Following operands are parameters
BRANCH_CTRL_ABI_RET   = 0x04  // Following operands are return destinations
```

#### 3.3.3 Memory Control
```
MEMORY_CTRL_ATOMIC    = 0x01  // Atomic operation
MEMORY_CTRL_VOLATILE  = 0x02  // Volatile access
MEMORY_CTRL_ALIGNED   = 0x03  // Enforce alignment
MEMORY_CTRL_UNALIGNED = 0x04  // Allow unaligned access
```

## 4. Register System

COIL uses a unified register model that provides consistent access across architectures while preserving direct access to hardware registers. Register references include:

1. General Purpose Registers (TYPE_RGP + index)
2. Floating Point Registers (TYPE_RFP + index)
3. Vector Registers (TYPE_RV + index)
4. Special Registers (TYPE_RS, TYPE_IP, TYPE_SP, etc.)

For cross-platform code, the variable system should be used instead of direct register manipulation. However, direct register access is always available when needed for performance or specialized functionality.

### 4.1 Register Operand Encoding

When a register is used as an operand, it's encoded as:

```
[type: uint16_t][register: uint8_t]
```

Where type is one of:
- TYPE_RGP (0x92): General purpose register
- TYPE_RFP (0x93): Floating point register
- TYPE_RV (0x94): Vector register
- TYPE_RS (0x95): Segment register
- TYPE_IP (0x9A): Instruction pointer
- TYPE_SP (0x9B): Stack pointer
- TYPE_BP (0x9C): Base/frame pointer

The register byte is interpreted according to the current architecture context.

### 4.2 CPU x86 Architecture Registers

The x86 architecture includes 16-bit, 32-bit, and 64-bit variants. Register encodings are consistent across these variants, with availability dependent on the current architectural context.

#### 4.2.1 Special x86 Registers
```
ip/eip/rip = TYPE_IP  // Instruction pointer (all x86 variants)
sp/esp/rsp = TYPE_SP  // Stack pointer (all x86 variants)
bp/ebp/rbp = TYPE_BP  // Base/frame pointer (all x86 variants)
```

#### 4.2.2 x86 General Purpose Registers (TYPE_RGP)

##### 8-bit Registers
```
// Available in all x86 variants
al = 0x00
cl = 0x01
dl = 0x02
bl = 0x03
ah = 0x04
ch = 0x05
dh = 0x06
bh = 0x07

// Additional registers in x86-64
spl  = 0x08  // Low byte of SP
bpl  = 0x09  // Low byte of BP
sil  = 0x0A  // Low byte of SI
dil  = 0x0B  // Low byte of DI
r8b  = 0x0C
r9b  = 0x0D
r10b = 0x0E
r11b = 0x0F
r12b = 0x10
r13b = 0x11
r14b = 0x12
r15b = 0x13
```

##### 16-bit Registers
```
// Available in all x86 variants
ax = 0x20
cx = 0x21
dx = 0x22
bx = 0x23
sp = 0x24
bp = 0x25
si = 0x26
di = 0x27

// Additional registers in x86-64
r8w  = 0x28
r9w  = 0x29
r10w = 0x2A
r11w = 0x2B
r12w = 0x2C
r13w = 0x2D
r14w = 0x2E
r15w = 0x2F
```

##### 32-bit Registers
```
// Available in x86-32 and x86-64
eax = 0x40
ecx = 0x41
edx = 0x42
ebx = 0x43
esp = 0x44
ebp = 0x45
esi = 0x46
edi = 0x47

// Additional registers in x86-64
r8d  = 0x48
r9d  = 0x49
r10d = 0x4A
r11d = 0x4B
r12d = 0x4C
r13d = 0x4D
r14d = 0x4E
r15d = 0x4F
```

##### 64-bit Registers
```
// Available in x86-64 only
rax = 0x60
rcx = 0x61
rdx = 0x62
rbx = 0x63
rsp = 0x64
rbp = 0x65
rsi = 0x66
rdi = 0x67
r8  = 0x68
r9  = 0x69
r10 = 0x6A
r11 = 0x6B
r12 = 0x6C
r13 = 0x6D
r14 = 0x6E
r15 = 0x6F
```

#### 4.2.3 x86 Segment Registers (TYPE_RS)
```
// Available in all x86 variants
CS = 0x00
DS = 0x01
ES = 0x02
SS = 0x03

// Available in 32-bit and 64-bit modes
FS = 0x04
GS = 0x05
```

#### 4.2.4 x86 Floating Point Registers (TYPE_RFP)

##### Legacy x87 FPU Registers
```
// Available in all x86 variants
ST0 = 0x00
ST1 = 0x01
ST2 = 0x02
ST3 = 0x03
ST4 = 0x04
ST5 = 0x05
ST6 = 0x06
ST7 = 0x07
```

##### SSE/AVX 128-bit Registers
```
// Available in modern x86 processors with SSE/AVX
XMM0  = 0x10
XMM1  = 0x11
XMM2  = 0x12
XMM3  = 0x13
XMM4  = 0x14
XMM5  = 0x15
XMM6  = 0x16
XMM7  = 0x17
// XMM8-15 are x86-64 only
XMM8  = 0x18
XMM9  = 0x19
XMM10 = 0x1A
XMM11 = 0x1B
XMM12 = 0x1C
XMM13 = 0x1D
XMM14 = 0x1E
XMM15 = 0x1F
```

#### 4.2.5 x86 Vector Registers (TYPE_RV)

##### AVX 256-bit Registers
```
// Available on processors with AVX
YMM0  = 0x00
YMM1  = 0x01
YMM2  = 0x02
YMM3  = 0x03
YMM4  = 0x04
YMM5  = 0x05
YMM6  = 0x06
YMM7  = 0x07
// YMM8-15 are x86-64 only
YMM8  = 0x08
YMM9  = 0x09
YMM10 = 0x0A
YMM11 = 0x0B
YMM12 = 0x0C
YMM13 = 0x0D
YMM14 = 0x0E
YMM15 = 0x0F
```

##### AVX-512 512-bit Registers
```
// Available on processors with AVX-512
ZMM0  = 0x10
ZMM1  = 0x11
// ... (ZMM registers continue)
ZMM31 = 0x2F
```

### 4.3 CPU ARM Architecture Registers

#### 4.3.1 ARM64 General Purpose Registers (TYPE_RGP)

##### 64-bit General Purpose
```
X0  = 0x00  // Parameter/Result
X1  = 0x01  // Parameter/Result
X2  = 0x02  // Parameter
// ... (continues as in original)
X30 = 0x1E  // Link register
```

##### 32-bit General Purpose (W0-W30 are lower 32 bits of X0-X30)
```
W0  = 0x40
W1  = 0x41
// ... (continues through W30 = 0x5E)
```

#### 4.3.2 ARM Special Registers
```
SP = TYPE_SP  // Stack pointer
PC = TYPE_IP  // Program counter
```

#### 4.3.3 ARM SIMD/Vector Registers (TYPE_RV)
```
V0  = 0x00
V1  = 0x01
// ... (continues)
V31 = 0x1F
```

### 4.4 CPU RISC-V Architecture Registers

#### 4.4.1 RISC-V General Purpose Registers (TYPE_RGP)
```
X0  = 0x00  // Zero register (hardwired to 0)
X1  = 0x01  // Return address (ra)
// ... (continues)
X31 = 0x1F  // Temporary (t6)
```

#### 4.4.2 RISC-V Floating Point Registers (TYPE_RFP)
```
F0  = 0x00  // FP temporary (ft0)
F1  = 0x01  // FP temporary (ft1)
// ... (continues)
F31 = 0x1F  // FP temporary (ft11)
```

### 4.5 GPU Architecture Registers

GPU architectures have specialized register sets that differ significantly from CPU architectures. COIL provides direct access to these registers when using GPU-specific contexts.

#### 4.5.1 NVIDIA PTX Registers (when ARCH_NVIDIA_PTX is active)
```
// GPU General Purpose Registers
R0  = 0x00
R1  = 0x01
// ... (continues)

// GPU Predicate Registers
P0  = 0x00
P1  = 0x01
// ... (continues)

// GPU Special Registers
LANEID    = 0x00  // Thread lane ID within warp
WARPID    = 0x01  // Warp ID within thread block
CTAID     = 0x02  // Thread block ID within grid
GRIDID    = 0x03  // Grid ID
```

#### 4.5.2 AMD GCN/RDNA Registers (when ARCH_AMD_GCN or ARCH_AMD_RDNA is active)
```
// Vector General Purpose Registers
V0  = 0x00
V1  = 0x01
// ... (continues)

// Scalar General Purpose Registers
S0  = 0x00
S1  = 0x01
// ... (continues)
```

### 4.6 ABI Register Mapping

When BRANCH_CTRL_ABI is used, COIL automatically maps function parameters and return values to the appropriate registers or memory locations based on the current architecture context:

#### 4.6.1 CPU x86-64 C ABI
- Return value: RAX (0x60)
- Parameters: RDI, RSI, RDX, RCX, R8, R9 (in order)
- Preserved: RBX, RBP, RSP, R12-R15

#### 4.6.2 CPU x86-32 C ABI
- Return value: EAX (0x40)
- Parameters: Stack-based [ESP+4], [ESP+8], etc.
- Preserved: EBX, ESI, EDI, EBP, ESP

#### 4.6.3 CPU x86-16 C ABI
- Return value: AX (0x20)
- Parameters: Stack-based [BP+4], [BP+6], etc.
- Preserved: BP, SI, DI

#### 4.6.4 CPU ARM64 C ABI
- Return value: X0 (0x00)
- Parameters: X0-X7 (in order)
- Preserved: X19-X29, SP

#### 4.6.5 CPU ARM32 C ABI
- Return value: R0 (0x00)
- Parameters: R0-R3 (in order)
- Preserved: R4-R11, SP

#### 4.6.6 CPU RISC-V64 C ABI
- Return value: X10 (a0, 0x0A)
- Parameters: X10-X17 (a0-a7, in order)
- Preserved: X8, X9, X18-X27 (s0-s11)

#### 4.6.7 GPU CUDA ABI
- Parameters: Special parameter registers
- Return value: Special return registers

## 5. Processing Unit Features and Capabilities

COIL recognizes the fundamental differences between processing unit types while providing a consistent programming model across them.

### 5.1 CPU-Specific Features

CPUs have features that are typically unavailable on other processing units:

1. **Interrupt Handling**: Instructions like INT, IRET, CLI, STI are specific to CPUs.
   
2. **Privilege Levels**: CPU-specific modes like kernel/user mode, ring levels, or exception levels.
   
3. **Memory Management**: Instructions for TLB and MMU operations.
   
4. **System Instructions**: Special instructions for system control (CPUID, MSR access, etc.).

When targeting CPUs, these features are directly accessible. When targeting other processing units, attempts to use these features will result in either emulation (if possible) or errors at compile time.

### 5.2 GPU-Specific Features

GPUs have unique execution models and features:

1. **Thread Hierarchy**: GPUs operate on a hierarchy of threads, warps/wavefronts, thread blocks/workgroups, and grids.
   
2. **Specialized Memory**: Shared memory, constant memory, texture memory with different access patterns.
   
3. **Synchronization**: Barrier instructions for thread synchronization.
   
4. **Vector Operations**: Wide vector operations and specialized matrix operations.

When targeting GPUs, these features are directly accessible. COIL provides abstractions for common GPU programming patterns while still allowing direct access to hardware features.

### 5.3 Feature Availability and Emulation

COIL takes a pragmatic approach to processing unit features:

1. **Native Execution**: When a feature is natively available on the target processing unit, COIL will use it directly.

2. **Transparent Emulation**: When a feature is not natively available but can be emulated, COIL will transparently emulate it.

3. **Compilation Error**: When a feature is fundamentally incompatible with a target processing unit (e.g., interrupt handling on a GPU), COIL will generate a compilation error.

### 5.4 Cross-Processing Unit Programming

When writing COIL code that targets multiple processing units:

1. **Variable-Based Code**: Code using COIL's variable system will automatically work across all supported processing units, with limitations based on fundamental processing unit capabilities.

2. **Direct Register Code**: Code using direct register access will be specific to the processing unit type and architecture variant.

3. **Processing Unit-Specific Code**: Use the SET_PROCUNIT and SET_ARCH directives to write specialized code for different processing units.

## 6. Instruction Set

[The instruction set remains largely unchanged from the original documentation.]

## 7. Processing Unit-Specific Instructions

COIL includes instructions that are specific to certain processing unit types. These instructions are only valid when the appropriate processing unit type is active.

### 7.1 CPU-Specific Instructions

These instructions are only valid when PROCUNIT_CPU is active:

#### 7.1.1 Interrupt Management
```
INT (0x04)    // Software interrupt
IRET (0x06)   // Return from interrupt
CLI (0xD2)    // Clear interrupt flag
STI (0xD3)    // Set interrupt flag
```

#### 7.1.2 System Management
```
CPUID (0xD0)  // Get CPU identification
RDTSC (0xD1)  // Read timestamp counter
HLT (0xD4)    // Halt processor
IN (0xD6)     // Input from port
OUT (0xD7)    // Output to port
RDMSR (0xD8)  // Read model-specific register
WRMSR (0xD9)  // Write model-specific register
```

### 7.2 GPU-Specific Instructions

These instructions are only valid when PROCUNIT_GPU is active:

#### 7.2.1 Thread Management
```
BARRIER (0xE0)          // Thread barrier synchronization
THREAD_ID (0xE1)        // Get current thread ID
BLOCK_ID (0xE2)         // Get current block/workgroup ID
GRID_ID (0xE3)          // Get current grid ID
THREAD_COUNT (0xE4)     // Get thread count in dimension
BLOCK_COUNT (0xE5)      // Get block/workgroup count in dimension
WARP_VOTE (0xE6)        // Warp-wide vote functions
SHUFFLE (0xE7)          // Warp shuffle operations
```

#### 7.2.2 Memory Management
```
SHARED_LOAD (0xF0)      // Load from shared memory
SHARED_STORE (0xF1)     // Store to shared memory
TEXTURE_LOAD (0xF2)     // Load from texture memory
CONSTANT_LOAD (0xF3)    // Load from constant memory
ATOMIC_GLOBAL (0xF4)    // Atomic operation on global memory
ATOMIC_SHARED (0xF5)    // Atomic operation on shared memory
```

## 8. Implementation Guidelines

### 8.1 Processing Unit and Architecture Awareness

When implementing COIL:

1. **Context Tracking**: Maintain the current processing unit type and architecture variant as part of the compilation context.

2. **Instruction Validation**: Validate instructions against the current processing unit type and architecture variant.

3. **Register Validation**: Ensure registers are valid for the current architecture variant.

4. **Emulation**: Implement emulation layers for features that can be reasonably emulated on different processing units.

5. **Error Handling**: Provide clear error messages when incompatible features are used.

### 8.2 Type Inference

The COIL ISA relies heavily on type inference to determine instruction behavior:

1. First check for parameter types (0xFA-0xFE) to identify instruction modifiers
2. For operations with multiple operands, the first non-parameter operand typically defines the destination
3. Use the widest type among operands when performing operations on mixed types
4. Respect explicit type qualifiers (TYPEEXT_*) when present

### 8.3 Instruction Encoding

For compact encoding:

1. Single-byte opcodes (0x00-0xFF) identify the instruction
2. For instructions with operands, the second byte contains the operand count
3. Each operand consists of a type field (uint16_t) followed by variable-length data
4. The type field encodes both the main type (first 8 bits) and type extensions (second 8 bits)

### 8.4 Memory Management

1. SCOPE_BEGIN and SCOPE_END instructions define variable lifetimes
2. Variable declarations within a scope are automatically managed
3. Memory fences (FENCE) provide synchronization primitives
4. PIN/UNPIN allow control over memory for DMA operations

### 8.5 Cross-Processing Unit Strategy

1. COIL enables writing portable code once and running it on any supported processing unit, with awareness of fundamental hardware differences
2. Features not available on a target will be transparently emulated when possible
3. Direct access to hardware registers and instructions is always available
4. Multi-processing unit programs can use SET_PROCUNIT and SET_ARCH directives to target specific processing units and architectures
5. Future extensions will support communication between processing units (e.g., CPU to GPU)

## 9. Examples

### 9.1 Cross-Platform Variable-Based Code

```
// This code will run on any CPU architecture
GLOBAL calculate_sum
ALIGN 4

calculate_sum:
    // Declare variables
    VAR_DECL INT a   // First parameter
    VAR_DECL INT b   // Second parameter
    VAR_DECL INT sum // Result

    // Simple addition
    ADD sum, a, b
    
    // Return the sum
    RET
```

### 9.2 CPU-Specific x86-64 Optimized Code

```
// x86-64 CPU optimized code
SET_PROCUNIT PROCUNIT_CPU
SET_ARCH ARCH_X86_64

GLOBAL vector_add_x64
ALIGN 16

vector_add_x64:
    // RDI = vec_a, RSI = vec_b, RDX = result, RCX = length
    MOV RAX, RCX        // Copy length to RAX
    SHR RAX, 2          // Divide by 4 (process 4 elements at a time)
    JZ cleanup          // If zero, go to cleanup
    
loop_vec:
    MOVDQU XMM0, [RDI]  // Load 4 integers from vec_a
    MOVDQU XMM1, [RSI]  // Load 4 integers from vec_b
    PADDD XMM0, XMM1    // Add 4 integers in parallel
    MOVDQU [RDX], XMM0  // Store result
    
    // Update pointers and counter
    ADD RDI, 16         // 16 bytes = 4 integers
    ADD RSI, 16
    ADD RDX, 16
    DEC RAX
    JNZ loop_vec
    
cleanup:
    // Handle remaining elements
    MOV RAX, RCX
    AND RAX, 3          // RAX = length % 4
    JZ done
    
loop_scalar:
    MOV EBX, [RDI]      // Load single integer
    ADD EBX, [RSI]      // Add
    MOV [RDX], EBX      // Store result
    
    // Update pointers
    ADD RDI, 4
    ADD RSI, 4
    ADD RDX, 4
    DEC RAX
    JNZ loop_scalar
    
done:
    RET
```

### 9.3 GPU-Specific NVIDIA PTX Code

```
// NVIDIA GPU-specific code
SET_PROCUNIT PROCUNIT_GPU
SET_ARCH ARCH_NVIDIA_PTX

GLOBAL vector_add_gpu
ALIGN 16

vector_add_gpu:
    // Get thread ID
    VAR_DECL INT tid
    THREAD_ID tid, x
    
    // Parameters (passed via special GPU registers)
    VAR_DECL PTR vec_a
    VAR_DECL PTR vec_b
    VAR_DECL PTR result
    VAR_DECL INT length
    
    // Bounds check
    CMP tid, length
    JMP done, BRANCH_COND_GE
    
    // Calculate address
    VAR_DECL INT offset
    MUL offset, tid, 4
    
    // Load values
    VAR_DECL INT val_a
    VAR_DECL INT val_b
    LOAD val_a, [vec_a + offset]
    LOAD val_b, [vec_b + offset]
    
    // Add and store
    VAR_DECL INT sum
    ADD sum, val_a, val_b
    STORE [result + offset], sum
    
done:
    RET
```

### 9.4 CPU-GPU Interoperation (Future Extension)

```
// Code that manages GPU execution from CPU
SET_PROCUNIT PROCUNIT_CPU
SET_ARCH ARCH_X86_64

GLOBAL launch_gpu_kernel
ALIGN 16

launch_gpu_kernel:
    // RDI = vec_a, RSI = vec_b, RDX = result, RCX = length
    
    // Pin memory for GPU access
    PIN RDI, RCX
    PIN RSI, RCX
    PIN RDX, RCX
    
    // Launch kernel (future extension)
    GPU_LAUNCH vector_add_gpu, RDI, RSI, RDX, RCX
    
    // Wait for completion
    GPU_SYNC
    
    // Unpin memory
    UNPIN RDI
    UNPIN RSI
    UNPIN RDX
    
    RET
```

## 10. Future Directions

COIL is designed as a foundational ISA that can grow to encompass all types of processing units:

1. **Processing Unit Interoperation**: Seamless communication between CPUs, GPUs, and other processing units.

2. **Standard Library Extensions**: OS-specific functionality like process management, file I/O, and cross-processing unit communication.

3. **Heterogeneous Computing**: Unified programming model for systems with multiple different processing units.

4. **Specialized Processing Units**: Support for AI accelerators, quantum processors, and other specialized computing devices.

5. **Dynamic Recompilation**: Runtime optimization across processing units based on workload characteristics.

The core "help, not block" philosophy will remain central to all future COIL extensions, ensuring that developers can access the full capability of any processing unit while maintaining code portability where appropriate and respecting the fundamental differences between processing unit types.